{"msg":"OK","code":0,"data":{"tpId":0,"prevTqUrl":"","isWantAnswer":false,"totalCommentCnt":307,"hasLatestSubmission":false,"allTagArray":[],"tqId":0,"nextTqUrl":"","isShowSimQuestion":false,"customizeHeadTitle":"","showDebug":false,"codingSubTagId":3,"questionTags":[{"acmTag":false,"baiyuanTag":false,"companyTag":false,"createTime":1417674707000,"creatorId":0,"customTag":false,"iconCode":0,"id":595,"info":"","jobTag":false,"name":"模拟","otherTag":false,"parentId":588,"searchLenevoTag":false,"smallTag":false,"systemTag":true}],"question":{"auditedQuestion":true,"caseCount":0,"cepingType":0,"choiceQuestion":false,"codeQuestion":true,"codeWithoutCaseQuestion":false,"content":"<div>  设计LRU(<span style=\"color: rgb(51,51,51);\">最近最少使用)</span>缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能 </div> <div>  1. set(key, value)：将记录(key, value)插入该结构 </div> <div>  2. get(key)：返回key对应的value值 </div> <div>  <br> </div> <div>  提示: </div> <div>  1.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的，然后都会刷新缓存。 </div> <div>  2.当缓存的大小超过K时，移除最不经常使用的记录。 </div> <div>  <div>   3.输入一个二维数组与K，二维数组每一维有2个或者3个数字，第1个数字为opt，第2，3个数字为key，value  </div>  <div>      若opt=1，接下来两个整数<span>key</span>, <span>value</span>，表示set(<span>key</span>, <span>value</span>)<br>    若opt=2，接下来一个整数<span>key</span>，表示get(<span>key</span>)，若<span>key</span>未出现过或已被移除，则返回-1<br>    对于每个<span>opt=2</span>，输出一个答案<br>  </div> </div> <div>  4.为了方便区分缓存里key与value，下面说明的<span>缓存里</span>key用&quot;&quot;号包裹 </div> <div>  <br> </div> <div>  进阶:你是否可以在<span>O(1)<span>的时间复杂度</span>完成</span>set和get操作 </div>","contestQuestion":false,"createTime":1593569738000,"creatorGroupId":0,"creatorHrUid":323944,"creatorId":323944,"cts":false,"ctsDepartmentId":0,"dataMiningQuestion":false,"delete":false,"designQuestion":false,"difficulty":3,"discardAnswerOrder":false,"discardSpace":false,"duration":0,"followedCount":0,"hiddenCorrect":true,"hint":"<img src=\"https://www.nowcoder.com/equation?tex=1%20%5Cleq%20K%20%5Cleq%20N%20%5Cleq%2010%5E5\"><br><img src=\"https://www.nowcoder.com/equation?tex=-2%20%5Ctimes%2010%5E9%20%5Cleq%20x%2Cy%20%5Cleq%202%20%5Ctimes%2010%5E9\">","hotLevel":0,"hotValue":0,"id":1006010,"judgeType":1,"likeTotal":852,"markBit":0,"memoryLimit":262144,"multi":0,"paidQuestion":false,"paperTotal":0,"parentId":0,"passRatio":0.0,"passTotal":38000,"personTotal":113311,"position":0,"problemId":208544,"refId":0,"referenceAnswer":"","referenceCreatorId":0,"samples":[{"input":"[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3","note":"[1,1,1]，第一个1表示opt=1，要set(1,1)，即将(1,1)插入缓存，缓存是{\"1\"=1}\n[1,2,2]，第一个1表示opt=1，要set(2,2)，即将(2,2)插入缓存，缓存是{\"1\"=1,\"2\"=2}\n[1,3,2]，第一个1表示opt=1，要set(3,2)，即将(3,2)插入缓存，缓存是{\"1\"=1,\"2\"=2,\"3\"=2}\n[2,1]，第一个2表示opt=2，要get(1)，返回是[1]，因为get(1)操作，缓存更新，缓存是{\"2\"=2,\"3\"=2,\"1\"=1}\n[1,4,4]，第一个1表示opt=1，要set(4,4)，即将(4,4)插入缓存，但是缓存已经达到最大容量3，移除最不经常使用的{\"2\"=2}，插入{\"4\"=4}，缓存是{\"3\"=2,\"1\"=1,\"4\"=4}\n[2,2]，第一个2表示opt=2，要get(2)，查找不到，返回是[1,-1]  ","output":"[1,-1]"},{"input":"[[1,1,1],[1,2,2],[2,1],[1,3,3],[2,2],[1,4,4],[2,1],[2,3],[2,4]],2","note":"","output":"[1,-1,-1,3,4]\n"}],"shareTotal":0,"shield":false,"showAnswer":false,"sourcePaperId":0,"specialDataStructureStrs":"","status":1,"supportLang":"java,cpp","supportSelfTest":true,"tags":"595","terminalOnlySeen":false,"tiankongQuestion":false,"tikuType":2,"tikuTypeName":"企业题库","timeLimit":2,"title":"设计LRU缓存结构","type":4,"typeName":"编程","uuid":"e3769a5f49894d49b871c09cadd13a61","viewTotal":8613,"visibility":1,"wantAnswerCount":0,"whereFrom":""},"hasAcceptSubmission":false,"customizeHeadUrl":"","allTopicArray":[],"tPage":0,"totalSolutionCnt":140,"isFollowed":false,"sourceTpId":0,"userCount":113311,"sourceQid":1006010,"codingProblem":{"mainModeProblem":true,"sqlProblem":false,"type":1,"setting":"{\"noInput\":false,\"deleteBlankLine\":true,\"autoDeleteSpace\":true}","supportEnhance":false,"limitLangStr":[],"frontProblem":false,"id":208544,"shellProblem":false,"inputSample":"[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3","submitLimit":32,"outputSample":"[1,-1]\n","paramsMainJson":"[{\"name\":\"operators\",\"desc\":\"the ops\",\"dataType\":\"INT\",\"container\":\"VECTOR_VECTOR\"},{\"name\":\"k\",\"desc\":\"the k\",\"dataType\":\"INT\",\"container\":\"DEFALUT\"}]","revision":14,"methodMainJson":"{\"methodName\":\"LRU\",\"methodDesc\":\"lru design\",\"returnDataType\":\"INT\",\"returnContainer\":\"VECTOR\",\"language\":\"2\"}","hint":"<img src=\"https://www.nowcoder.com/equation?tex=1%20%5Cleq%20K%20%5Cleq%20N%20%5Cleq%2010%5E5\"><br><img src=\"https://www.nowcoder.com/equation?tex=-2%20%5Ctimes%2010%5E9%20%5Cleq%20x%2Cy%20%5Cleq%202%20%5Ctimes%2010%5E9\">","memoryLimit":262144,"limitLang":[],"template":"","questionId":1006010,"caseCount":16,"tCLProblem":false,"title":"设计LRU缓存结构","content":"<div>  设计LRU(<span style=\"color: rgb(51,51,51);\">最近最少使用)</span>缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能 </div> <div>  1. set(key, value)：将记录(key, value)插入该结构 </div> <div>  2. get(key)：返回key对应的value值 </div> <div>  <br> </div> <div>  提示: </div> <div>  1.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的，然后都会刷新缓存。 </div> <div>  2.当缓存的大小超过K时，移除最不经常使用的记录。 </div> <div>  <div>   3.输入一个二维数组与K，二维数组每一维有2个或者3个数字，第1个数字为opt，第2，3个数字为key，value  </div>  <div>      若opt=1，接下来两个整数<span>key</span>, <span>value</span>，表示set(<span>key</span>, <span>value</span>)<br>    若opt=2，接下来一个整数<span>key</span>，表示get(<span>key</span>)，若<span>key</span>未出现过或已被移除，则返回-1<br>    对于每个<span>opt=2</span>，输出一个答案<br>  </div> </div> <div>  4.为了方便区分缓存里key与value，下面说明的<span>缓存里</span>key用&quot;&quot;号包裹 </div> <div>  <br> </div> <div>  进阶:你是否可以在<span>O(1)<span>的时间复杂度</span>完成</span>set和get操作 </div>","dataFile":"9c0c4f58144b4ccb88ca2022a06bb57b.zip","vOJProblem":false,"cssTemplate":"\n/**\n * lru design\n * @param operators int整型二维数组 the ops\n * @param operatorsRowLen int operators数组行数\n * @param operatorsColLen int* operators数组列数\n * @param k int整型 the k\n * @return int整型一维数组\n * @return int* returnSize 返回数组行数\n */\nint* LRU(int** operators, int operatorsRowLen, int* operatorsColLen, int k, int* returnSize ) {\n    // write code here\n}","supportMem":false,"standardSubmissionIds":"","timeLimit":2,"outputLimit":16000,"pDF":false,"testCasesExt":"{\"samples\":[{\"output\":\"[1,-1]\",\"input\":\"[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3\",\"note\":\"[1,1,1]，第一个1表示opt=1，要set(1,1)，即将(1,1)插入缓存，缓存是{\\\"1\\\"=1}\\n[1,2,2]，第一个1表示opt=1，要set(2,2)，即将(2,2)插入缓存，缓存是{\\\"1\\\"=1,\\\"2\\\"=2}\\n[1,3,2]，第一个1表示opt=1，要set(3,2)，即将(3,2)插入缓存，缓存是{\\\"1\\\"=1,\\\"2\\\"=2,\\\"3\\\"=2}\\n[2,1]，第一个2表示opt=2，要get(1)，返回是[1]，因为get(1)操作，缓存更新，缓存是{\\\"2\\\"=2,\\\"3\\\"=2,\\\"1\\\"=1}\\n[1,4,4]，第一个1表示opt=1，要set(4,4)，即将(4,4)插入缓存，但是缓存已经达到最大容量3，移除最不经常使用的{\\\"2\\\"=2}，插入{\\\"4\\\"=4}，缓存是{\\\"3\\\"=2,\\\"1\\\"=1,\\\"4\\\"=4}\\n[2,2]，第一个2表示opt=2，要get(2)，查找不到，返回是[1,-1]  \",\"index\":1},{\"output\":\"[1,-1,-1,3,4]\\n\",\"input\":\"[[1,1,1],[1,2,2],[2,1],[1,3,3],[2,2],[1,4,4],[2,1],[2,3],[2,4]],2\",\"note\":\"\",\"index\":2}]}","supportLang":"java,cpp"},"rp":0}}